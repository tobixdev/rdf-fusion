use graphfusion_model::NamedNode;
use std::fmt;

/// A GraphFusion builtin name.
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub enum BuiltinName {
    // SPARQL Builtin Scalar Functions
    Str,
    Lang,
    LangMatches,
    Datatype,
    Iri,
    BNode,
    Rand,
    Abs,
    Ceil,
    Floor,
    Round,
    Concat,
    SubStr,
    StrLen,
    Replace,
    UCase,
    LCase,
    EncodeForUri,
    Contains,
    StrStarts,
    StrEnds,
    StrBefore,
    StrAfter,
    Year,
    Month,
    Day,
    Hours,
    Minutes,
    Seconds,
    Timezone,
    Tz,
    Now,
    Uuid,
    StrUuid,
    Md5,
    Sha1,
    Sha256,
    Sha384,
    Sha512,
    StrLang,
    StrDt,
    IsIri,
    IsBlank,
    IsLiteral,
    IsNumeric,
    Regex,
    Bound,
    Coalesce,
    If,

    // Scalar Built-in Aggregate Functions
    Count,
    Sum,
    Min,
    Max,
    Avg,
    Sample,
    GroupConcat,

    // Comparison functions
    SameTerm,
    Equal,
    GreaterThan,
    GreaterOrEqual,
    LessThan,
    LessOrEqual,

    // Numeric functions
    Add,
    Div,
    Mul,
    Sub,
    UnaryMinus,
    UnaryPlus,

    // Conversion Functions
    AsString,
    AsInteger,
    AsInt,
    AsFloat,
    AsDouble,
    AsDecimal,
    AsDateTime,
    AsBoolean,

    // Other Necessary Functions
    EffectiveBooleanValue,
    NativeBooleanAsTerm,
    IsCompatible,
}

impl fmt::Display for BuiltinName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Str => f.write_str("STR"),
            Self::Lang => f.write_str("LANG"),
            Self::LangMatches => f.write_str("LANGMATCHES"),
            Self::Datatype => f.write_str("DATATYPE"),
            Self::Iri => f.write_str("IRI"),
            Self::BNode => f.write_str("BNODE"),
            Self::Rand => f.write_str("RAND"),
            Self::Abs => f.write_str("ABS"),
            Self::Ceil => f.write_str("CEIL"),
            Self::Floor => f.write_str("FLOOR"),
            Self::Round => f.write_str("ROUND"),
            Self::Concat => f.write_str("CONCAT"),
            Self::SubStr => f.write_str("SUBSTR"),
            Self::StrLen => f.write_str("STRLEN"),
            Self::Replace => f.write_str("REPLACE"),
            Self::UCase => f.write_str("UCASE"),
            Self::LCase => f.write_str("LCASE"),
            Self::EncodeForUri => f.write_str("ENCODE_FOR_URI"),
            Self::Contains => f.write_str("CONTAINS"),
            Self::StrStarts => f.write_str("STRSTARTS"),
            Self::StrEnds => f.write_str("STRENDS"),
            Self::StrBefore => f.write_str("STRBEFORE"),
            Self::StrAfter => f.write_str("STRAFTER"),
            Self::Year => f.write_str("YEAR"),
            Self::Month => f.write_str("MONTH"),
            Self::Day => f.write_str("DAY"),
            Self::Hours => f.write_str("HOURS"),
            Self::Minutes => f.write_str("MINUTES"),
            Self::Seconds => f.write_str("SECONDS"),
            Self::Timezone => f.write_str("TIMEZONE"),
            Self::Tz => f.write_str("TZ"),
            Self::Now => f.write_str("NOW"),
            Self::Uuid => f.write_str("UUID"),
            Self::StrUuid => f.write_str("STRUUID"),
            Self::Md5 => f.write_str("MD5"),
            Self::Sha1 => f.write_str("SHA1"),
            Self::Sha256 => f.write_str("SHA256"),
            Self::Sha384 => f.write_str("SHA384"),
            Self::Sha512 => f.write_str("SHA512"),
            Self::StrLang => f.write_str("STRLANG"),
            Self::StrDt => f.write_str("STRDT"),
            Self::IsIri => f.write_str("isIRI"),
            Self::IsBlank => f.write_str("isBLANK"),
            Self::IsLiteral => f.write_str("isLITERAL"),
            Self::IsNumeric => f.write_str("isNUMERIC"),
            Self::Regex => f.write_str("REGEX"),
            Self::If => f.write_str("IF"),
            Self::SameTerm => f.write_str("SAMETERM"),
            Self::Equal => f.write_str("EQ"),
            Self::GreaterThan => f.write_str("GT"),
            Self::GreaterOrEqual => f.write_str("GEQ"),
            Self::LessThan => f.write_str("LT"),
            Self::LessOrEqual => f.write_str("LEQ"),
            Self::Add => f.write_str("ADD"),
            Self::Div => f.write_str("DIV"),
            Self::Mul => f.write_str("MUL"),
            Self::Sub => f.write_str("SUB"),
            Self::AsString => f.write_str("xsd:string"),
            Self::AsInteger => f.write_str("xsd:integer"),
            Self::AsInt => f.write_str("xsd:int"),
            Self::AsFloat => f.write_str("xsd:float"),
            Self::AsDouble => f.write_str("xsd:double"),
            Self::AsDecimal => f.write_str("xsd:decimal"),
            Self::AsDateTime => f.write_str("xsd:dataTime"),
            Self::AsBoolean => f.write_str("xsd:boolean"),
            Self::EffectiveBooleanValue => f.write_str("EFFECTIVE_BOOLEAN_VALUE"),
            Self::NativeBooleanAsTerm => f.write_str("BOOLEAN_AS_TERM"),
            Self::Bound => f.write_str("BOUND"),
            Self::IsCompatible => f.write_str("IS_COMPATIBLE"),
            Self::Coalesce => f.write_str("COALESCE"),
            Self::UnaryMinus => f.write_str("MINUS"),
            Self::UnaryPlus => f.write_str("PLUS"),
            Self::Count => f.write_str("COUNT"),
            Self::Sum => f.write_str("SUM"),
            Self::Min => f.write_str("MIN"),
            Self::Max => f.write_str("MAX"),
            Self::Avg => f.write_str("AVG"),
            Self::Sample => f.write_str("SAMPLE"),
            Self::GroupConcat => f.write_str("GROUP_CONCAT"),
        }
    }
}
